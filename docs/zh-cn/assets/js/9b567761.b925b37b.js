"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5074],{7866:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial/pub/sign/sign","title":"Signing archives, packages, checksums","description":"Signing ensures that the artifacts have been generated by yourself, and your","source":"@site/docs/tutorial/pub/sign/sign.mdx","sourceDirName":"tutorial/pub/sign","slug":"/tutorial/pub/sign/","permalink":"/zh-cn/docs/tutorial/pub/sign/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Cataloging artifacts","permalink":"/zh-cn/docs/tutorial/pub/sbom"},"next":{"title":"Signing Binaries","permalink":"/zh-cn/docs/tutorial/pub/sign/binary_sign"}}');var t=i(4848),a=i(8453);const r={},o="Signing archives, packages, checksums",l={},c=[{value:"Usage",id:"usage",level:2},{value:"Available variable names",id:"available-variable-names",level:3},{value:"Signing with cosign",id:"signing-with-cosign",level:2},{value:"Signing executables",id:"signing-executables",level:2},{value:"With gon",id:"with-gon",level:3},{value:"With cosign",id:"with-cosign",level:3},{value:"Signing Docker images and manifests",id:"signing-docker-images-and-manifests",level:2},{value:"Limitations",id:"limitations",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"signing-archives-packages-checksums",children:"Signing archives, packages, checksums"})}),"\n",(0,t.jsx)(n.p,{children:"Signing ensures that the artifacts have been generated by yourself, and your\nusers can verify that by comparing the generated signature with your public\nsigning key."}),"\n",(0,t.jsx)(n.p,{children:"Kmdo provides means to sign both executables and archives."}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(n.p,{children:"Signing works in combination with checksum files, and it is generally enough\nto sign the checksum files only."}),"\n",(0,t.jsxs)(n.p,{children:["The default is configured to create a detached signature for the checksum files\nwith ",(0,t.jsx)(n.a,{href:"https://www.gnupg.org/",children:"GnuPG"}),", and your default key."]}),"\n",(0,t.jsx)(n.p,{children:"To enable signing just add this to your configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:"signs:\n  - artifacts: checksum\n"})}),"\n",(0,t.jsx)(n.p,{children:"To customize the signing pipeline you can use the following options:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:'signs:\n  - #\n    # ID of the sign config, must be unique.\n    #\n    # Default: \'default\'.\n    id: foo\n\n    # Name of the signature file.\n    #\n    # Default: \'${artifact}.sig\'.\n    # Templates: allowed.\n    signature: "${artifact}_sig"\n\n    # Path to the signature command\n    #\n    # Default: \'gpg\'.\n    cmd: gpg2\n\n    # Command line arguments for the command\n    #\n    # to sign with a specific key use\n    # args: ["-u", "<key id, fingerprint, email, ...>", "--output", "${signature}", "--detach-sign", "${artifact}"]\n    #\n    # Default: ["--output", "${signature}", "--detach-sign", "${artifact}"].\n    # Templates: allowed.\n    args: ["--output", "${signature}", "${artifact}", "{{ .ProjectName }}"]\n\n    # Which artifacts to sign\n    #\n    # Valid options are:\n    # - none        no signing\n    # - all:        all artifacts\n    # - checksum:   checksum files\n    # - source:     source archive\n    # - package:    Linux packages (deb, rpm, apk, etc)\n    # - archive:    archives from archive pipe\n    # - sbom:       any SBOMs generated for other artifacts\n    # - binary:     binaries (only when `archives.format` is \'binary\', use binary_signs otherwise)\n    #\n    # Default: \'none\'.\n    artifacts: all\n\n    # IDs of the artifacts to sign.\n    #\n    # If `artifacts` is checksum or source, this fields has no effect.\n    ids:\n      - foo\n      - bar\n\n\n    # Stdin data to be given to the signature command as stdin.\n    #\n    # Templates: allowed.\n    stdin: "{{ .Env.GPG_PASSWORD }}"\n\n    # StdinFile file to be given to the signature command as stdin.\n    stdin_file: ./.password\n\n    # Sets a certificate that your signing command should write to.\n    #\n    # You can later use `${certificate}` or `.Env.certificate` in the `args` section.\n    #\n    # This is particularly useful for keyless signing with cosign, and should\n    # not usually be used otherwise.\n    #\n    # Note that this should be a name, not a path.\n    #\n    # Templates: allowed.\n    certificate: \'{{ trimsuffix .Env.artifact ".tar.gz" }}.pem\'\n\n    # List of environment variables that will be passed to the signing command\n    # as well as the templates.\n    env:\n      - FOO=bar\n      - HONK=honkhonk\n\n    # By default, the stdout and stderr of the signing cmd are discarded unless\n    # Kmdo is running with `--verbose` set.\n    # You can set this to true if you want them to be displayed regardless.\n    output: true\n'})}),"\n",(0,t.jsx)(n.h3,{id:"available-variable-names",children:"Available variable names"}),"\n",(0,t.jsx)(n.p,{children:"These environment variables might be available in the fields that accept\ntemplates:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"${artifact}"}),": the path to the artifact that will be signed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"${artifactID}"}),": the ID of the artifact that will be signed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"${certificate}"}),": the certificate filename, if provided"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"${signature}"}),": the signature filename"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"signing-with-cosign",children:"Signing with cosign"}),"\n",(0,t.jsxs)(n.p,{children:["You can sign your artifacts with ",(0,t.jsx)(n.a,{href:"https://github.com/sigstore/cosign",children:"cosign"})," as well."]}),"\n",(0,t.jsxs)(n.p,{children:["Assuming you have a ",(0,t.jsx)(n.code,{children:"cosign.key"})," in the repository root and a ",(0,t.jsx)(n.code,{children:"COSIGN_PWD"}),"\nenvironment variable set, a simple usage example would look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:'signs:\n  - cmd: cosign\n    stdin: "{{ .Env.COSIGN_PWD }}"\n    args:\n      - "sign-blob"\n      - "--key=cosign.key"\n      - "--output-signature=${signature}"\n      - "${artifact}"\n      - "--yes" # needed on cosign 2.0.0+\n    artifacts: all\n'})}),"\n",(0,t.jsx)(n.p,{children:"Your users can then verify the signature with:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"cosign verify-blob -key cosign.pub -signature file.tar.gz.sig file.tar.gz\n"})}),"\n",(0,t.jsx)(n.h2,{id:"signing-executables",children:"Signing executables"}),"\n",(0,t.jsx)(n.p,{children:"Executables can be signed after build using post hooks."}),"\n",(0,t.jsx)(n.h3,{id:"with-gon",children:"With gon"}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/mitchellh/gon",children:"gon"})," was discontinued by its maintainer, but it lives on in a\n",(0,t.jsx)(n.a,{href:"https://github.com/Bearer/gon",children:"fork"}),", which we'll use here."]})}),"\n",(0,t.jsxs)(n.p,{children:["For example, you can use ",(0,t.jsx)(n.a,{href:"https://github.com/Bearer/gon",children:"gon"})," to create notarized macOS apps:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:"builds:\n  - binary: foo\n    id: foo\n    goos:\n      - linux\n      - windows\n    goarch:\n      - amd64\n\n  # notice that we need a separated build for the MacOS binary only:\n  - binary: foo\n    id: foo-macos\n    goos:\n      - darwin\n    goarch:\n      - amd64\n    hooks:\n      post: gon gon.hcl\n"})}),"\n",(0,t.jsx)(n.p,{children:"And:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-terraform",children:'# gon.hcl\n#\n# The path follows a pattern\n# ./dist/BUILD-ID_TARGET/BINARY-NAME\nsource = ["./dist/foo-macos_darwin_amd64/foo"]\nbundle_id = "com.mitchellh.example.terraform"\n\napple_id {\n  username = "mitchell@example.com"\n  password = "@env:AC_PASSWORD"\n}\n\nsign {\n  application_identity = "Developer ID Application: Mitchell Hashimoto"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Note that notarizing may take some time, and will need to be run from a macOS\nmachine."}),"\n",(0,t.jsxs)(n.p,{children:["If you generate ZIP or DMG as part of your signing via gon you may need to\nensure their file names align with desired pattern of other artifacts as\nKmdo doesn't control how these get generated beyond just executing ",(0,t.jsx)(n.code,{children:"gon"}),"\nwith given arguments. Relatedly you may need to list these additional artifacts\nas ",(0,t.jsx)(n.code,{children:"extra_files"})," in the ",(0,t.jsx)(n.code,{children:"release"})," section to make sure they also get uploaded."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also check\n",(0,t.jsx)(n.a,{href:"https://github.com/kumose/kmdo/issues/1227",children:"this issue"})," for more\ndetails."]}),"\n",(0,t.jsx)(n.h3,{id:"with-cosign",children:"With cosign"}),"\n",(0,t.jsxs)(n.p,{children:["You can also use ",(0,t.jsx)(n.a,{href:"https://github.com/sigstore/cosign",children:"cosign"})," to sign the binaries directly, but you'll need to\nmanually add the ",(0,t.jsx)(n.code,{children:".sig"})," files to the release and/or archive:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:'builds:\n  - hooks:\n      post:\n        - sh -c "COSIGN_PASSWORD=$COSIGN_PWD cosign sign-blob --key cosign.key --output-signature dist/{{ .ProjectName }}_{{ .Version }}_{{ .Target }}.sig {{ .Path }}"\n\n# add to the release directly:\nrelease:\n  extra_files:\n    - glob: dist/*.sig\n\n# or just to the archives:\narchives:\n  - files:\n      - dist/*.sig\n'})}),"\n",(0,t.jsx)(n.p,{children:"While this works, I would recommend using the signing pipe directly."}),"\n",(0,t.jsx)(n.h2,{id:"signing-docker-images-and-manifests",children:"Signing Docker images and manifests"}),"\n",(0,t.jsxs)(n.p,{children:["Please refer to ",(0,t.jsx)(n.a,{href:"/zh-cn/docs/tutorial/pub/sign/docker_sign",children:"Docker Images Signing"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.p,{children:"You can sign with any command that either outputs a file or modify the file\nbeing signed."}),"\n",(0,t.jsxs)(n.p,{children:["If you want to sign with something that writes to ",(0,t.jsx)(n.code,{children:"STDOUT"})," instead of a file,\nyou can wrap the command inside a ",(0,t.jsx)(n.code,{children:"sh -c"})," execution, for instance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'title=".kmdopkg.yaml"',children:'signs:\n  - cmd: sh\n    args:\n      - "-c"\n      - \'echo "${artifact} is signed and I can prove it" | tee ${signature}\'\n    artifacts: all\n'})}),"\n",(0,t.jsxs)(n.p,{children:["And it will work just fine. Just make sure to always use the ",(0,t.jsx)(n.code,{children:"${signature}"}),"\ntemplate variable as the result file name and ",(0,t.jsx)(n.code,{children:"${artifact}"})," as the origin file."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);